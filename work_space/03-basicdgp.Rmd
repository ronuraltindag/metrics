# Generating (population) data, sampling from the population, and deriving sample estimates of population parameters

```{css, echo=FALSE}
.badCode {
background-color: #ffffcf;
  color: black;
}
```

```{r, include=FALSE}

need <- c('glue', 'dplyr','readxl', 'haven', 'ggplot2','tidyr', 'tufte', 'formatR','knitr','rmdformats','ggplot2')

have <- need %in% rownames(installed.packages()) 
if(any(!have)) install.packages(need[!have]) 
invisible(lapply(need, library, character.only=T)) 

knitr::opts_chunk$set(echo = TRUE)
#change path to whereever you place the models
# script_folder = dirname(rstudioapi::getSourceEditorContext()$path)
# setwd(glue('{script_folder}'))

birthday<-"01011990" #january 1, 1990
set.seed(as.integer(birthday))
```

## Goals 

* Simulate a data-generating process (DGP) from scratch, given the population parameters 
* Show how to sample from the DGP to generate sample estimates
* Understand why these sample estimates can be different from the population values

* **Note** : Code chunks with STUDENTS are for intented to teach students, CHALLENGE are challenging but students with some programming skills can easily learn, PROF are for students with advanced programming skills and instructors.

## Overview

* Data are observed as a result of a data generating process (from hereon, DGP). You can think of a coin flip as a data generating process for a binary outcome (Bernoulli distribution).

* In practice, we are more often working with data that follow a DGP that is (a) more complex, and (b) unknown. But to build intuition in this course, we will work a lot with simple, known DGPs.

## Generating data from a known linear univariate DGP

* So let's perform a data generating process for a dependent variable $$y$$ which is given by the linear function $$y = \beta_0 + \beta_1 * x +  u$$ where $\beta_0$ is the sum of the 1st and 2nd digit of my birthday, $\beta_1$ is the sum of the 3rd and 4th digit of my birthday, x is distributed normal with mean of 10 and variance of the first non-zero digit of my birthday, and u is (independently) distributed normal with mean 0 and variance of the last non-zero digit of your birthday. 

* Let's say the "population" is 1MM observations.

* So generate all the components, and then multiply and sum them to generate the column for Y, and combine all columns into a single dataframe.

```{r}
n <- 1000000
u<-rnorm(n, 0, sqrt(9))
x<-rnorm(n, 10,sqrt(1))
beta0<-1
beta1<-1
y<-beta0+beta1*x+u
df<-data.frame(y,x,u) 
head(df)
``` 

## Sampling from the population 

* Next, we will take a sample from the population data of 1,000 observation. 
```{r}
sample<- df[sample(nrow(df), 1000, replace = FALSE), ]
nrow(sample)
```

## Calculating sample estimates 

* And let's manually calculate b0 and b1 using the functions sum() and var() in R.
```{r}
ybar<-mean(sample$y)
ybar
xbar<-mean(sample$x)
xbar

beta1_hat<-cov(sample$y,sample$x)/var(sample$x)
beta0_hat<-ybar-beta1_hat*xbar

print(beta0_hat)
print(beta1_hat)
```

* So our sample-derived regression function is $$y = `r beta0_hat` + `r beta1_hat`*x + u$$


## Plot the data with the fitted line
```{r}
sample$predictedvalues  <-beta0_hat + beta1_hat*sample$x

ggplot(sample, aes(x, y)) +
  geom_point() +
  geom_line(aes(x, predictedvalues))
```
  


## Calculating TSS, ESS, and $R^2$

```{r}
sample$predictedvalues  <-beta0_hat + beta1_hat*sample$x

sample$residuals  <-sample$y-sample$predictedvalues

TSS  <-sum((sample$y-ybar)^2)

ESS  <-sum((sample$predictedvalues-ybar)^2)

r2  <-ESS/TSS

r2

```

* Let's now show that for any individual observation, TSS_i != ESS_i + RSS_i:

```{r}

sample$TSS_i  <-(sample$y-ybar)^2

sample$ESS_i  <-(sample$predictedvalues-ybar)^2

sample$RSS_i <- (sample$y-sample$predictedvalues)^2

sample$check_i<-sample$TSS_i-sample$ESS_i-sample$RSS_i
summary(sample$check_i)
```
* But that it works in aggregate:

```{r}

check_sum<-sum(sample$TSS_i)-sum(sample$ESS_i)-sum(sample$RSS_i)

check_sum

```

## Algebraic properties of the estimator
Show that sum(U) from previous problem =~ 0. Show that sum(X*u)~=0.
```{r}
sum(sample$residuals)

sample$XU<- sample$residuals*sample$x
sum(sample$XU)
```

